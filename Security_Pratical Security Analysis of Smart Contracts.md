# Securify: Pratical Security Analysis of Smart Contracts

## Securify的实现过程

### Step1:将EVM字节码进行编译

将EVM字节码作为传入参数，通过编译将其转化为静态单赋值的无栈表示。在此次编译过程中，最主要的是去除了栈（例如：使用本地变量代替push instruction），除了移除栈之外，Security是可以识别方法的。

在编译之后，Securify对于memory和storage的便宜量以及目标跳转的分析不够完全，在论文后续的Section6中会提及优化的问题。

### Step2:推断语义事实

在进行编译之后，Securify会分析合约来推断语义事实（包含了合约中的所有行为），其中包括数据和控制流的依赖关系。

Securify对语义事实的派生在分层数据日志中以声明方式指定，并使用现有的可拓展的引擎实现完全自动化。

声明性方法的好处：

1.推理规则简洁地捕获了关于不同组件的抽象推理（例如，合同存储）

2.更多的事实和推理规则易被加入

3.推理规则以模块化的方式指定（例如，内存分析独立于智能合约的存储分析而指定）

### Step3:检查安全模板

在获取语义事实之后，Securify会检测合规和违规模式，这些pattern是使用特殊的DSL语言编写的。



DSL（domain-specific language):针对某一领域，具有首先表达性的一种计算机语言

DSL编程：声明式编程，其核心思想是语义模型。

DSL其中最为典型和常见的例子就是我们所常说的正则表达式。



## Securify的实现

### Decompiler（反编译器）

反编译器将EVM字节码作为输入转化为汇编指令（参考ics，因为相关字节码都是有相应的汇编指令），然后反编译器将EVM指令转化为SSA（single-static assignment,静态单一赋值的形式），转化为SSA的好处是实现无栈的效果，具体体现在是将相关的stack指令去除（pop,push)。此外还有在反编译指令的基础之上建立控制流图（CFG)。

### Optimization（优化）

Securify主要使用了三种优化方法：

1.未使用的指令，优化中删除那些结果未被使用的指令（主要是将无用指令删除，进行分析），这样实验下来可以减少合约中44%的指令，提高了可拓展性以及后续分析的准确性。

2.部分求值，沿计算过程传播常量，可以提高storage和memory分析的准确性，准确性的提高主要可以体现在除法余数的问题上。正如我们在求值中所示，部分求值可以解决存储/内存指令中出现的70%以上的偏移量。（减少内存，因为传递常量可以减少内存的消耗）

3.函数内联，通过使静态分析与上下文相关，提高静态分析的精度。

### Inference of Semantic facts

Securify通过使用指定在分层数据日志中的推理规则，来获取语义事实。(这一步使用的是Datalog中的Souffle Datalog Solver来有效的计算一个包含所有语义事实的集合)

### Evaluating pattern

为了检查安全模板，Securify通过迭代的方式来解决模板中的all和some(任意和存在)量词。为了检查推理事实，可以直接通过查询fixed-point（fixed-point 是由 Datalog solver 计算的）来确定。如果有pattern匹配到了，那么Securify会将指令标记为易被攻击的，并且将错误位置显示给用户。当然，若没有相关pattern匹配到，那么我们将其标记为warning,那么warning往往是需要人工来解决的。



## Securify软件的评估

为了对于Securify软件的评估，本文主要是进行了一下实验

### 1.对于真实世界中合约中正确性的证明以及漏洞的查询

由论文Section7中的相关数据可以得出以下结论：Securify的合规和违规模式具有足够的表达性来证明相关的安全属性，有其在反证方面（也就是寻找漏洞）。

此外可以通过利用Securify的拓展性，来对于warning的内容转变为violations或者compliances。

### 2.人工审查Securify对于合约判断的结果

在进行人工审查时，使用的数据集不一样，导致图像上出现的数据可能与1实验所获得的图像不一样，其中最为明显的是（handled Exception property HE）,在2中它不明有所谓的warning出现，也就是代表无论是合规或者是违规模板他必定是匹配到一个。主要分析下来，原因有两点：一是Contract数据集中的Solidity代码是仍然处于开发阶段，而对于EVM字节码则是已经部署到区块链上，其本身的安全漏洞肯定是处于开发阶段更多一点；二是不排除有人故意上传问题代码，主要是用来测试Securify的正确性。

根据这步实验，我们得到的结论就是对于不同的安全属性，证明的效率和正确率是完全不一样的，主要也是和pattern的本质化有关

### 3.将Securify与Oyente，Mythril(这两种也是著名的智能合约检测工具，主要是通过符号执行来检测漏洞)进行比较

对于所有安全性质除了可重入外，Oyente和Mythril往往会漏报许多真实存在的漏洞。并且这两种工具无法对于所有可考虑到的安全属性的漏洞进行检测。

### 4.测试Securify的反编译器在解决内存和存储偏移方面的成功率

主要需要的是memory offse比storage offset更多被解析，因为后者往往依赖于用户所提供的相关数据。

### 5.测试Securify的时间和内存消耗

## 相关问题的提出和解释

### 关于Datalog中的fixed-point问题，首先是对于fixed-point中文的翻译：表面上是定点，最好是理解为定论。

具体解释是如果知道Follow这样一个谓词是正确的，并且可以由语义事实Follow推出的相应的语义事实MayFollow是正确的，我们将其放置在fixed-point中，也就是fixed-point中放置的是相应的正确的语义事实，也可以称之为推论。

根据rule，从一开始初步已有的比如Follow这样的语义事实，从而推导出确定的结论，我们将所有的结论称之为定论集。



### Securify的本质核心：

是使用Datalog来语义表达智能合约，然后通过作者提出的rule,以及Datalog Solver 去判断当前合约是否有违背rule的情况，如果有的话就是漏洞。

其实Securify的效率本质上取决于pattern的编写，如果pattern的编写更加本质化，那么对于漏洞的检测那么效率会更高（主要体现在误判和漏判的占比上）

关于pattern的本质化，以可重入漏洞为例，可重入漏洞pattern的编写的层面是具有多样性的，比如可以从资金流向的角度来进行判断，或者是可重入漏洞每次转账的数量是一样的。但是第二种pattern思考角度就存在较大的误报嫌疑，如果我多次转相同数量的ether你们就会出现误判的情况。

### 关于图灵完备的理解（由于EVM是图灵完备的，所以准确检查安全性质是不可能的）

首先是对于图灵完备的定义：一切可以计算的问题都能计算，这样的虚拟机和编程语言我们将其称为图灵完备的。

主要是非图灵完备的语言和虚拟机可能会更安全，个人理解可能是计算的东西是有限的；而对于图灵完备的语言可能会更加智能。学长的解释是本质上是复杂度的问题，不完备，程序越简单月可控。

